// Generated by CoffeeScript 1.6.1
var config, countdownIntervalID, countdownStart, countdownValue, eco, express, fs, getStatus, hipchat, hungryCount, io, isHungry, log4js, onCountdownUpdate, path, removeHungry, reset, resetTimeoutID, server, setHungry, socket, status, update, users;

config = require('./config.js').config;

express = require('express');

fs = require('fs');

path = require('path');

eco = require('eco');

hipchat = require('./hipchat.js');

io = require('socket.io').listen(config.sockets_port);

log4js = require('log4js');

log4js.replaceConsole();

status = 'waiting';

users = {};

socket = null;

countdownStart = null;

countdownIntervalID = null;

countdownValue = config.countdown;

resetTimeoutID = null;

io.enable('browser client minification');

io.enable('browser client etag');

io.enable('browser client gzip');

io.set('log level', config.log_level);

io.set('transports', config.transports);

server = express();

server.configure(function() {
  server.use('/static', express["static"](path.join(__dirname, '/static')));
  server.use(express.bodyParser());
  return server.use(function(req, res, next) {
    res.header('Access-Control-Allow-Origin', config.allowedDomains);
    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    return next();
  });
});

server.get('/', function(req, res) {
  var context, template;
  template = fs.readFileSync(path.join(__dirname + "/index.eco.html"), "utf-8");
  context = {};
  return res.send(eco.render(template, context));
});

server.get('/channel', function(req, res) {
  var context, template;
  template = fs.readFileSync(path.join(__dirname + "/channel.eco.html"), "utf-8");
  context = {};
  return res.send(eco.render(template, context));
});

server.post('/reset', function(req, res) {
  reset();
  return res.json(getStatus());
});

server.post('/hungry', function(req, res) {
  var author, hungry, message;
  hungry = (req.body.hungry === 'true') || (req.body.hungry === 'on');
  author = req.body.author || "Anonymous";
  status = getStatus().status;
  if (hungry) {
    setHungry(author);
    message = "Ok, we heared you: you are hungry!";
  } else {
    if (status !== 'leaving') {
      removeHungry(author);
      message = "We canceled your hunger request";
    } else {
      message = "The train is already about to leave, too late to cancel now";
    }
  }
  return res.json({
    author: author,
    hungry: hungry,
    message: message,
    count: hungryCount()
  });
});

server.post('/status', function(req, res) {
  var author;
  author = req.body.author || null;
  return res.json(getStatus(author));
});

hungryCount = function() {
  return Object.keys(users).length || 0;
};

isHungry = function(author) {
  if (users[author] != null) {
    return true;
  } else {
    return false;
  }
};

setHungry = function(author) {
  users[author] = {
    date: +new Date()
  };
  return update();
};

removeHungry = function(author) {
  if (getStatus().status !== 'leaving') {
    delete users[author];
    return update();
  }
};

getStatus = function(author) {
  var count, countdown, current, previousStatus;
  if (author == null) {
    author = null;
  }
  previousStatus = status;
  count = hungryCount();
  status = 'waiting';
  countdown = countdownValue;
  if (count >= config.leaveat) {
    status = 'leaving';
    if (countdownStart == null) {
      countdownStart = new Date();
      clearInterval(countdownIntervalID);
      countdownIntervalID = setInterval(onCountdownUpdate, 1000);
    }
    if (countdown <= 0) {
      status = 'departed';
      if (previousStatus !== 'departed') {
        console.log("START RESET TIMER -> call reset in " + config.resetAllDelay + "s");
        clearTimeout(resetTimeoutID);
        resetTimeoutID = setTimeout(reset, config.resetAllDelay * 1000);
      }
    }
  }
  current = {
    status: status,
    count: count,
    countdown: countdown
  };
  if (author) {
    current.author = author;
    current.hungry = isHungry(author);
  }
  if (previousStatus !== status) {
    console.log("status: ", previousStatus, '->', status);
    if (status === 'leaving' && previousStatus === 'waiting') {
      hipchat.leaving();
    }
    if (status === 'departed' && previousStatus === 'leaving') {
      hipchat.departed();
    }
  }
  return current;
};

update = function() {
  var statusObject;
  statusObject = getStatus();
  console.log("update", statusObject);
  return io.sockets.emit('update', statusObject);
};

reset = function() {
  console.log("RESET");
  users = {};
  socket = null;
  clearTimeout(resetTimeoutID);
  clearInterval(countdownIntervalID);
  countdownStart = null;
  countdownIntervalID = null;
  countdownValue = config.countdown;
  return update();
};

onCountdownUpdate = function() {
  var countdown, diff;
  diff = +new Date() - countdownStart.getTime();
  countdown = config.countdown - Math.round(diff / 1000);
  countdownValue = countdown;
  if (countdown <= 0) {
    clearInterval(countdownIntervalID);
    console.log("finished!");
  }
  return update();
};

console.log("http server running on port " + config.server_port);

console.log("sockets server running on port " + config.sockets_port);

server.listen(config.server_port);
